# -*- coding: utf-8 -*-
"""final-pcos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M0MrHyRIyjHowLQGdeU98OE1xw2CMUJB
"""

import numpy as np
import os
import PIL
import PIL.Image
import tensorflow as tf
import tensorflow_datasets as tfds
from tensorflow.keras.metrics import BinaryAccuracy, Precision, Recall, AUC

data_dir='/content/drive/MyDrive/PCOSGen-train/dataset/train'
batch_size = 32
img_height = 180
img_width = 180

train_ds, val_ds = tf.keras.utils.image_dataset_from_directory(
    data_dir,
    validation_split=0.2,
    subset="both",
    seed=123,
    image_size=(img_height, img_width),
    batch_size=batch_size,
)

from matplotlib import pyplot as plt

batch = train_ds.as_numpy_iterator().next()

img, labels = batch

plt.figure(figsize=(15,10))
i = 1
for image, label in zip(img,labels):
    plt.subplot(4,8,i)
    plt.imshow(image/255.)
    plt.axis('off')
    plt.title(label)
    i += 1

# Create a MirroredStrategy.
strategy = tf.distribute.MirroredStrategy()
print('Number of devices: {}'.format(strategy.num_replicas_in_sync))

num_classes = 2

with strategy.scope():
    model = tf.keras.Sequential([
        tf.keras.layers.InputLayer((None,None, 3)),
        tf.keras.layers.Reshape((180,180,3)),
        tf.keras.layers.Rescaling(1./255),
        tf.keras.layers.Conv2D(256, 8, activation='relu'),  # Additional convolutional layer
        tf.keras.layers.MaxPooling2D(),
        tf.keras.layers.Conv2D(128, 16, activation='relu'),  # Additional convolutional layer
        tf.keras.layers.MaxPooling2D(),
        tf.keras.layers.Conv2D(64, 32, activation='relu'),  # Additional convolutional layer
        tf.keras.layers.MaxPooling2D(),
#         tf.keras.layers.Conv2D(32, 128, activation='relu'),
#         tf.keras.layers.MaxPooling2D(),
#         tf.keras.layers.Conv2DTranspose(64,64, activation = 'relu'),
#         tf.keras.layers.MaxPooling2D(),
#         tf.keras.layers.Conv2DTranspose(128,32, activation = 'relu'),
#         tf.keras.layers.MaxPooling2D(),
#         tf.keras.layers.Conv2DTranspose(256,16, activation = 'relu'),
#         tf.keras.layers.MaxPooling2D(),
        tf.keras.layers.Flatten(),
        tf.keras.layers.Dense(256, activation='relu'),  # Additional dense layer
        tf.keras.layers.Dense(128, activation='relu'),
        tf.keras.layers.Dense(num_classes, activation = 'softmax')
    ])
    model.compile(
          optimizer='adam',
          loss= tf.keras.losses.SparseCategoricalCrossentropy(),
          metrics=['accuracy'])

model.summary()

history = model.fit(
  train_ds,
  validation_data=val_ds,
  epochs=50
)

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.legend(['Training','Validation'])
plt.show()

plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.xlabel("Epochs")
plt.ylabel("Accuracy")
plt.legend(['Training','Validation'])
plt.show()

# Assuming you have a training dataset called train_ds
training_accuracy = model.evaluate(train_ds)[1]
print("Training Accuracy:", training_accuracy)

# Assuming you have a training dataset called train_ds
training_accuracy = model.evaluate(val_ds)[1]
print("Training Accuracy:", training_accuracy)

model.save('/content/drive/MyDrive/PCOSGen-train/models/pcos_final.h5')

pip install tf-keras-vis

model = tf.keras.models.load_model('/content/drive/MyDrive/PCOSGen-train/models/PCOSGen-train.h5')

from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Create an ImageDataGenerator for the testing data
test_datagen = ImageDataGenerator(rescale=1./255)  # You can customize the preprocessing as needed

# Load the testing dataset
test_generator = test_datagen.flow_from_directory(
    '/content/drive/MyDrive/PCOSGen-train/dataset/val',
    target_size=(180, 180),  # Replace with the target image size
    batch_size=1,
    class_mode=None,  # Replace with the appropriate class mode for your dataset
    shuffle=False  # Ensure that the data is not shuffled for consistency with the indices
)

# # Get the filenames and predictions for the testing data
# filenames = test_generator.filenames
# predictions = model.predict(test_generator)

# # Determine the best 5 frames based on the predictions
# best_frames_indices = np.argsort(predictions[:, 5])[-5:]  # Replace predicted_class_index with the index of the predicted class

import numpy as np
from tensorflow.keras.preprocessing import image

# Load and preprocess individual testing images
image_paths = ['/content/drive/MyDrive/PCOSGen-train/dataset/train/0/100image87.jpg','/content/drive/MyDrive/PCOSGen-train/dataset/train/0/100image94.jpg','/content/drive/MyDrive/PCOSGen-train/dataset/train/0/101image14.jpg']  # Replace with the actual paths to your testing images
images = [image.load_img(img_path, target_size=(180, 180)) for img_path in image_paths]
images = np.array([image.img_to_array(img) / 255.0 for img in images])  # Preprocess the images

# Make predictions on the individual testing images
predictions = model.predict(images)

# Determine the best frames based on the predictions
best_frames_indices = np.argsort(predictions[:, 1])[-5:]  # Replace predicted_class_index with the index of the predicted class

from tf_keras_vis.gradcam import Gradcam
from tf_keras_vis.utils import normalize

# Initialize the Grad-CAM visualizer
gradcam = Gradcam(model, model_modifier=None)

# Visualize the interpretability for each of the best frames
# for index in best_frames_indices:
#     # Generate the heatmap for the selected frame
#     heatmap = gradcam(normalize(images[index]),
#                       'conv2d_2',
#                       None,
#                       images[index])

#     # Plot the heatmap overlay on the original image
#     plt.imshow(images[index])  # Show the original image
#     plt.imshow(heatmap, cmap='jet', alpha=0.5)  # Overlay the heatmap
#     plt.show()

image='/content/drive/MyDrive/PCOSGen-train/dataset/val/image10000.jpg'

def get_score(image):
    # Calculate the score for the image
    score = model.predict(image)
    return score

def get_score(image):
    # Calculate the score for the image
    score = model.predict(image)
    return score

Score = get_score  # Assigning the function to the variable Score

print(Score)

print(type(Score))

from tf_keras_vis.utils.scores import CategoricalScore

# 1 is the imagenet index corresponding to Goldfish, 294 to Bear and 413 to Assault Rifle.
score = CategoricalScore([0,1])

from tf_keras_vis.utils.model_modifiers import ReplaceToLinear

replace2linear = ReplaceToLinear()

# Instead of using ReplaceToLinear instance,
# you can also define the function from scratch as follows:
# def model_modifier_function(cloned_model):
#     cloned_model.layers[-1].activation = tf.keras.activations.linear



# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# from matplotlib import cm
# from tf_keras_vis.gradcam import Gradcam
# 
# # Create Gradcam object
# gradcam = Gradcam(model,
#                   model_modifier=replace2linear,
#                   clone=True)
# 
# # Generate heatmap with GradCAM
# cam = gradcam(score,
#               images,
#               penultimate_layer=-1)
# 
# ## Since v0.6.0, calling `normalize()` is NOT necessary.
# # cam = normalize(cam)
# 
# # Render
#

heatmap = np.uint8(cm.jet(cam[1])[..., :3] * 255)

plt.imshow(images[1])
plt.imshow(heatmap, cmap='jet', alpha=0.5)

import matplotlib.pyplot as plt
import numpy as np

# Provided heatmap values
heatmap = np.array([[0.09583074, 0.09999729, 0.07499798]])

# Visualize the heatmap
plt.imshow(heatmap, cmap='hot', interpolation='nearest')
plt.colorbar()
plt.show()

